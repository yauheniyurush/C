//подключаем необходимые заголовочные файлы стандартной библиотеки
#include<stdio.h>
#include<stdlib.h>
#include<string.h>
//подключаем созданный заголовочный файл
#include "header.h"

//пишем главную функцию программы
void main()
{	
	//объявляем переменные
	//переменная для выбранного пользователем номера команды
	int n=0;
	//перем. для временного хранения стр-ры, для передачи её из одной функции в другую	
	Student std;
	//указатели на первый и последний элемент связанных структур	
	Student *begin=NULL, *end=NULL;  
	
	//пользовательское меню
	//1.добавить запись в список студентов 2.отредактировать запись в списке 
	//3.сохр. список в файл 4.загруз. список из файла 5.вывести список на экран 
	//6.выход
L:  printf("\n1.add    3.save   5.print  \n2.edit   4.load   6.exit   \n");
	printf("Input the command number (from 1 to 6): ");
	//сохраняем введённое пользователем значение в переменной n
	scanf("%d", &n);
	
	//в зав-ти от введённого пользователем значения (1-5) запуск. соотв. функции,
	//при вводе '6' (6й команды) выходим без ошибки
	switch(n) 
	{
	case 1: //принимаем значения от пользователя во временную структуру std
			getUser(&std);
			//связываем заполненную польз-ем стр-ру std с имеющимися структурами
		    end=addEnd(&std,end,0);
			//при первом заполнении стр-ры указатели на 1 и последн. структуру равны
			if (begin==NULL) begin=end;  
			break;
	case 2: //редактируем выбранную пользователем строку
			editStd(begin, &end, &begin);
			break;
	case 3: //сохраняем список в файл
			saveList(begin,"list.dat"); break;
	case 4:	//загружаем список из файла
			loadList(begin,"list.dat",&end, &begin); break;
	case 5: //печатаем список на экран
			printList (begin); break;
	case 6: //завершаем программу без ошибки
			exit(0); break;
	}
	//при вводе пользователем значения не равного 1,2,3,4,5,6
	//просим пользователя ввести команду ещё раз
	goto L; 
}

//функция для приёма значений от пользователя
//вход параметр: указатель на структуру
void getUser(Student *p)
{
	Student tmp;
	//поочерёдно запрашиваем и принимаем информацию от пользователя
	printf("\nInput name :");
	fflush(stdin);
	fgets(tmp.fname,MAXFNAME,stdin);
	//удаляем символ завершения строки кот. добавился функцией fgets
	tmp.fname[strlen(tmp.fname)-1]='\0';
	printf("Input floor: ");
	scanf("%d", &tmp.floor);
	fflush(stdin);
	printf("Input room number: ");
	scanf("%d", &tmp.roomNmb);
	
	//указатели на пред. след. структуру укажем позже 
	tmp.pnext = tmp.pprev = NULL;
	//копируем структуру tmp в структуру по указателю p (вход. пар-р)
	*p = tmp;
}

//функция (Ф) для связывания заполненной польз-ем структуры с имеющимся списком 
//структур. Ф принимает: заполненную структуру, указатель на последнюю
//структуру в списке, номер в списке который необходимо заполнить для 
//добавляемого студента (т.к. данная ф-я еще используется при загрузке
//списка из файла). Ф возвращает: указатель на структуру который записывается в 
//переменную end - указатель на последнюю структуру
Student* addEnd(Student *p, Student *end, int stnumb)
{
	//выделяем память для структуры, помещаем указатель на неё в pAdd
	Student *pAdd=(Student*)malloc(sizeof(Student));
	//заполняем память по адресу pAdd переданной, через параметр указатель p, структурой
	*pAdd=*p; 
	if (end==NULL) //если добавляем первый элемент 
	{
		//в указатель end помещаем указатель на заполненную структуру
		end=pAdd;
		//если переданный параметр stnumb равен нулю, тогда номеру в списке присваиваем 1
		//иначе значение равное переданному параметру stnumb
		if (stnumb==0) pAdd->studNmb=1;
		else pAdd->studNmb=stnumb;
	}
	else //если добавляем не первый элемент
	{
		end->pnext = pAdd;//связываем последний элемент с добавляемым
		pAdd->pprev=end;  //связываем добавляемый элемент с последним 
		//если переданный параметр stnumb равен нулю, тогда номер в списке присваиваем
		//номер последней строки в списке плюс один
		if (stnumb==0) pAdd->studNmb=end->studNmb+1;
		else  pAdd->studNmb=stnumb;
		end= pAdd;
	}
	//возвращаем указатель на последний элемент
	return end;
}
//функция для редактирования выбранных пользователем строк
//вход. пар-ры: указатель на первую структуру, 
//указатель на указатель последней в списке структуры,
//указатель на указатель первой в списке структуры,
int editStd(Student *p, Student **pend, Student **pbegin)
{	//объявляем переменные
	int n, k;
	Student *s, std;
	//выводим список на экран и предлагаем выбрать номер строки
	printList (p);
	printf("Input number of student: ");
	scanf("%d", &n);
	//находим структуру номер в списке кот. равен выбранному
	while(p!=NULL) {
	if (p->studNmb==n){	s=p; break;}	
	p=p->pnext;	}
	//предлагаем выбрать номер команды "что сделать со строкой"
L:	printf("\nWhat do you want to do with it? \n1.edit \n2.delete\
 \n3.exit to the main menu \nInput the command number : ");
	scanf("%d", &k);
	switch(k)
	{
	case 1: //при редактировании строки запрашиваем переввести данные
			getUser(&std);//и сохраняем их в структуру std 
			//в выбранную пользователем строку вносим изменения 
			strncpy(s->fname,std.fname,sizeof(std.fname));
			s->roomNmb=std.roomNmb; s->floor=std.floor;
			goto M; //выход из цикла
	case 2: //удаляем строку функцией deleteStd, передаём в неё
			//указатель на удаляемую стр-ру, на первый и последний эл-ты списка 
			deleteStd(s, pend, pbegin); goto M; //и выходим из цикла
	case 3: goto M;	//выход из цикла в главное меню
	}
	goto L;  //переспрашиваем номер команды если введённой значение не 1,2,3
M:	return 0;//выходим без кода об ошибке
}
//удаление строки из списка, параметры идентичные функции editStd
int deleteStd(Student *p, Student **pend, Student **pbegin) 
{
	Student *pr=NULL, *pn=NULL;//указатели для пред. след. эл. списка
	if (p->pnext==NULL) //если удаляемая строка последняя
	{
		pr=p->pprev; //сохраняем в pr указатель на предыд. эл. списка
		if(pr!=NULL) //если предыд. эл. есть
		{
			pr->pnext=NULL; //обнуляем указатель в пред. эл-те
			*pend=pr;       //предыдущий элемент объявляем последним
		
		} else //если предыд. элемента нет (т.е. элемент в списке один)
		{
			*pend=NULL; //последний и первый элементы списка обнуляем
			*pbegin=NULL;
		}
	}
	else if (p->pprev==NULL) //если удаляемая строка первая
	{
		pn=p->pnext; //сохраняем в pn указатель на след. эл. списка
		*pbegin=pn;  //указатель на первый элемент меняем на pn
		pn->pprev=NULL; //в след эл-те обнуляем указатель на пред. эл-т
	}
	else //если удаляемая стр. ни первая ни последняя
	{
		pn=p->pnext; //сохраняем в pn указатель на след. эл. списка
		pr=p->pprev; //сохраняем в pr указатель на предыд. эл. списка
   //связываем указ-ли предыдущ. и след. эл-та так как тек. эл-т удаляем
		pn->pprev=p->pprev; 
		pr->pnext=p->pnext;
	}
	free(p); //освобождаем память по указателю тек. элемента
	p=NULL;  //обнуляем указатель
	return 0; //выходим без кода ошибки
}
//функция записи списка в файл
//параметр: указатель на первый элемент списка и название файла
void saveList(Student *p, char *file)
{
	//объявляем указатель pf типа FILE, открываем/создаём файл
	//функцией fopen (режим символьн. записи), и помещаем указатель на файл в pf
	FILE *pf=fopen(file,"w");
	//если файл успешно открыт/создан
	if (pf!=NULL)
	{
		while(p!=NULL)//проходимся по всем элементам списка
		{	
		//и записываем элементы структур в файл
		fprintf(pf,"%d %s %d %d\n", p->studNmb, p->fname, p->roomNmb, p->floor);
		p=p->pnext;
		}	
		fclose(pf);//закрываем файл
	}
}

//функция загрузки списка из файла, параметры:
//указатель на структуру типа Student, название файла, указатель на 
//указ-ль на первый эл-т списка, указ-ль на указ-ль на последний эл-т списка
void loadList(Student *p, char *file, Student **pend, Student **pbegin)
{	
	Student tmp, *ptmp;//
	//объявляем указатель pf типа FILE, открываем/создаём файл
	//функцией fopen (режим символьн. чтения), и помещаем указатель на файл в pf
	FILE *pf=fopen(file,"r");
	//если файл успешно открыт/создан
	if (pf!=NULL)
	{	
		//очищаем текущий список структур
		while(p!=NULL)
		{
			ptmp=p->pnext;
			deleteStd(p, *pend, *pbegin);
			p=ptmp;
		}
		*pend=NULL;
		*pbegin=NULL;
		//пока не достигнут конец файла читаем данные во временную структуру tmp
		while(!feof(pf))
		{	
			fscanf(pf,"%d %s %d %d\n", &tmp.studNmb, &tmp.fname, &tmp.roomNmb, &tmp.floor);
			tmp.pnext = tmp.pprev = NULL;
			//запускаем функцию addEnd, передаём в неё указатель на заполненную временную структуру,
			//указатель на указатель последнего элемента списка, и номер записываемого элемента в списке
			//функция добавит полученную из файла структуру в список
			*pend=addEnd(&tmp,*pend,tmp.studNmb);
			//если элемент первый то последний элемент равен первому элементу
			if (*pbegin==NULL) *pbegin=*pend;
		}
		fclose(pf);//закрываем файл
	}
}
//функция вывода списка на экран принимает указатель на структуру
void printList(Student *p)
{
	//выводим шапку таблицы
	printf("\n%s %s %s %s \n","# ","Name                     ","Floor ","Room ");
	printf("%s \n","----------------------------------------");
	
	//циклом проходимся по элементам списка и выводим их на экран 
	//ниже описанной функцией print
	while(p!=NULL)
	{
		print(p);
		p=p->pnext;
	}
}
//функция печати строки списка н экран
void print(Student *p)
{
	printf("%-2d %-25s %-6d %-3d \n", p->studNmb, p->fname, p->floor, p->roomNmb);
}