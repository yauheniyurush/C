//подключаем необходимые заголовочные файлы стандартной библиотеки
#include<stdio.h>
#include<stdlib.h>
#include<string.h>
//подключаем созданный заголовочный файл
#include "header.h"


//функция для приёма значений от пользователя
//вход параметр: указатель на структуру
void getUser(Student *p)
{
	int i,k;
	Student tmp;
	//поочерёдно запрашиваем и принимаем информацию от пользователя
	printf("\nInput name :");
	fflush(stdin);
	fgets(tmp.fname,MAXFNAME,stdin);
	//удаляем символ завершения строки кот. добавился функцией fgets
	tmp.fname[strlen(tmp.fname)-1]='\0';
	printf("Input floor: ");
	scanf("%d", &tmp.floor);
	fflush(stdin);
	printf("Input room number: ");
	scanf("%d", &tmp.roomNmb);
	for(i=0;i<5;i++)
	{
		for(k=0;k<12;k++) tmp.marks[i][k]=0;
	}
	//указатели на пред. след. структуру укажем позже 
	tmp.pnext = tmp.pprev = NULL;
	//копируем структуру tmp в структуру по указателю p (вход. пар-р)
	*p = tmp;
}

//функция (Ф) для связывания заполненной польз-ем структуры с имеющимся списком 
//структур. Ф принимает: заполненную структуру, указатель на последнюю
//структуру в списке, номер в списке который необходимо заполнить для 
//добавляемого студента (т.к. данная ф-я еще используется при загрузке
//списка из файла). Ф возвращает: указатель на структуру который записывается в 
//переменную end - указатель на последнюю структуру
Student* addEnd(Student *p, Student *end, int stnumb)
{
	
	//выделяем память для структуры, помещаем указатель на неё в pAdd
	Student *pAdd=(Student*)malloc(sizeof(Student));
	//заполняем память по адресу pAdd переданной, через параметр указатель p, структурой
	//инициалзируем поля массива с оценками нулями
	
	*pAdd=*p; 
	if (end==NULL) //если добавляем первый элемент 
	{
		//в указатель end помещаем указатель на заполненную структуру
		end=pAdd;
		//если переданный параметр stnumb равен нулю, тогда номеру в списке присваиваем 1
		//иначе значение равное переданному параметру stnumb
		if (stnumb==0) pAdd->studNmb=1;
		else pAdd->studNmb=stnumb;
	}
	else //если добавляем не первый элемент
	{
		end->pnext = pAdd;//связываем последний элемент с добавляемым
		pAdd->pprev=end;  //связываем добавляемый элемент с последним 
		//если переданный параметр stnumb равен нулю, тогда номер в списке присваиваем
		//номер последней строки в списке плюс один
		if (stnumb==0) pAdd->studNmb=end->studNmb+1;
		else  pAdd->studNmb=stnumb;
		end= pAdd;
	}
	//возвращаем указатель на последний элемент
	return end;
}
//функция для редактирования выбранных пользователем строк
//вход. пар-ры: указатель на первую структуру, 
//указатель на указатель последней в списке структуры,
//указатель на указатель первой в списке структуры,
int editStd(Student *p, Student **pend, Student **pbegin)
{	//объявляем переменные
	int n, k;
	Student *s, std;
	//выводим список на экран и предлагаем выбрать номер строки
	printList (p,0);
	printf("Input number of student: ");
	scanf("%d", &n);
	//находим структуру номер в списке кот. равен выбранному
	while(p!=NULL) {
	if (p->studNmb==n){	s=p; break;}	
	p=p->pnext;	}
	//предлагаем выбрать номер команды "что сделать со строкой"
L:	printf("\nWhat do you want to do with it? \n1.edit \n2.delete\
 \n3.add marks \n4.exit to the main menu \nInput the command number : ");
	scanf("%d", &k);
	switch(k)
	{
	case 1: //при редактировании строки запрашиваем переввести данные
			getUser(&std);//и сохраняем их в структуру std 
			//в выбранную пользователем строку вносим изменения 
			strncpy(s->fname,std.fname,sizeof(std.fname));
			s->roomNmb=std.roomNmb; s->floor=std.floor;
			goto M; //выход из цикла
	case 2: //удаляем строку функцией deleteStd, передаём в неё
			//указатель на удаляемую стр-ру, на первый и последний эл-ты списка 
			deleteStd(s, pend, pbegin); goto M; //и выходим из цикла
	case 3: //запускаем функцию добавления оценок
			addMarks(s); goto M;
	case 4: goto M;	//выход из цикла в главное меню
	}
	goto L;  //переспрашиваем номер команды если введённой значение не 1,2,3
M:	return 0;//выходим без кода об ошибке
}
//удаление строки из списка, параметры идентичные функции editStd
int deleteStd(Student *p, Student **pend, Student **pbegin) 
{
	Student *pr=NULL, *pn=NULL;//указатели для пред. след. эл. списка
	if (p->pnext==NULL) //если удаляемая строка последняя
	{
		pr=p->pprev; //сохраняем в pr указатель на предыд. эл. списка
		if(pr!=NULL) //если предыд. эл. есть
		{
			pr->pnext=NULL; //обнуляем указатель в пред. эл-те
			*pend=pr;       //предыдущий элемент объявляем последним
		
		} else //если предыд. элемента нет (т.е. элемент в списке один)
		{
			*pend=NULL; //последний и первый элементы списка обнуляем
			*pbegin=NULL;
		}
	}
	else if (p->pprev==NULL) //если удаляемая строка первая
	{
		pn=p->pnext; //сохраняем в pn указатель на след. эл. списка
		*pbegin=pn;  //указатель на первый элемент меняем на pn
		pn->pprev=NULL; //в след эл-те обнуляем указатель на пред. эл-т
	}
	else //если удаляемая стр. ни первая ни последняя
	{
		pn=p->pnext; //сохраняем в pn указатель на след. эл. списка
		pr=p->pprev; //сохраняем в pr указатель на предыд. эл. списка
   //связываем указ-ли предыдущ. и след. эл-та так как тек. эл-т удаляем
		pn->pprev=p->pprev; 
		pr->pnext=p->pnext;
	}
	free(p); //освобождаем память по указателю тек. элемента
	p=NULL;  //обнуляем указатель
	return 0; //выходим без кода ошибки
}
//функция записи списка в файл
//параметр: указатель на первый элемент списка и название файла
void saveList(Student *p, char *file)
{
	int i, k;
	//объявляем указатель pf типа FILE, открываем/создаём файл
	//функцией fopen (режим символьн. записи), и помещаем указатель на файл в pf
	FILE *pf=fopen(file,"w");
	//если файл успешно открыт/создан
	if (pf!=NULL)
	{
		while(p!=NULL)//проходимся по всем элементам списка
		{	
		//и записываем элементы структур в файл
		fprintf(pf,"%d %s %d %d ", p->studNmb, p->fname, p->roomNmb, p->floor);
		//записываем оценки
		for(i=0;i<5;i++)
		{
		for(k=0;k<12;k++) fprintf(pf,"%d ", p->marks[i][k]);
		}
		//переносим указатель на сл. строку
		fprintf(pf,"\n");
		p=p->pnext;
		}	
		fclose(pf);//закрываем файл
	}
}

//функция загрузки списка из файла, параметры:
//указатель на структуру типа Student, название файла, указатель на 
//указ-ль на первый эл-т списка, указ-ль на указ-ль на последний эл-т списка
void loadList(Student *p, char *file, Student **pend, Student **pbegin)
{	
	int i, k;
	Student tmp, *ptmp;
	//объявляем указатель pf типа FILE, открываем/создаём файл
	//функцией fopen (режим символьн. чтения), и помещаем указатель на файл в pf
	FILE *pf=fopen(file,"r");
	//если файл успешно открыт/создан
	if (pf!=NULL)
	{	
		//очищаем текущий список структур
		while(p!=NULL)
		{
			ptmp=p->pnext;
			deleteStd(p, *pend, *pbegin);
			p=ptmp;
		}
		*pend=NULL;
		*pbegin=NULL;
		//пока не достигнут конец файла читаем данные во временную структуру tmp
		while(!feof(pf))
		{	
			fscanf(pf,"%d %s %d %d", &tmp.studNmb, &tmp.fname, &tmp.roomNmb, &tmp.floor);
			//
			for(i=0;i<5;i++)
			{
			for(k=0;k<12;k++) fscanf(pf,"%d ", &tmp.marks[i][k]);
			}
			fscanf(pf,"\n");
			tmp.pnext = tmp.pprev = NULL;
			//запускаем функцию addEnd, передаём в неё указатель на заполненную временную структуру,
			//указатель на указатель последнего элемента списка, и номер записываемого элемента в списке
			//функция добавит полученную из файла структуру в список
			*pend=addEnd(&tmp,*pend,tmp.studNmb);
			//если элемент первый то последний элемент равен первому элементу
			if (*pbegin==NULL) *pbegin=*pend;
		}
		fclose(pf);//закрываем файл
	}
}
//функция вывода списка на экран принимает указатель на структуру
//и вещественное число-флаг
void printList(Student *p, int k)//#КР2
{
	//объявляем переменную типа указатель на функцию
	//которая возвращает указатель на строку и принимает указатель на символ 
	char (*fnc)(char *);
	//выводим шапку таблицы
	printf("\n%s %s %s %s \n","# ","Name                     ","Floor ","Room ");
	printf("%s \n","----------------------------------------");
	
	//если переданный параметр k равен 1, тогда
	//передаём в указатель fnc адрес функции strupr
	//которая преобразует символы строки в верхний регистр
	if (k==1) fnc=&strupr;
	//если переданный параметр k равен 2, тогда
	//передаём в указатель fnc адрес функции strlwr
	//которая преобразует символы строки в нижний регистр
	else if (k==2) fnc=&strlwr;
	//иначе записываем в указатель NULL
	else fnc=NULL;
	//циклом проходимся по элементам списка и выводим их на экран 
	//ниже описанной функцией print
	while(p!=NULL)
	{
		print(p,fnc);
		p=p->pnext;
	}
}
//функция печати строки списка на экран
//параметры: указатель на структуру типа Student и
//указатель на функцию кот. возвращает char, принимает
//параметр указатель на char
void print(Student *p, char (*fnc)(char *))//#КР2
{
	//объявл. массив символов размером поял имя структуры Student
	char s [MAXFNAME];
	//копируем в s имя студента
	strcpy(s, p->fname);
	//если передали указатель на функцию (не NULL), 
	//используем её для преобразования строки s
	if ((*fnc)!=NULL)
	{
	(*fnc)(s);
	}
	//печатаем поля структуры,вместо имени печатаем то что храниться в s
	printf("%-2d %-25s %-6d %-3d \n", p->studNmb, s, p->floor, p->roomNmb);
}

//функция печати списка студентов в верхнем и нижнем регистре
//параметр указатель на структуру типа Student
int printReg(Student *p)//#КР2
{
	int      n;
	//запрашиваем у пользователя тип регистра в котором вывести список
	printf("\nWhat letter case do you want?");
	printf("\n1.UPPER \n2.lower");
	printf("\nInput the number (1-2):");
	scanf("%d", &n);
	//в зависимости от выбранного регистра передаём 
	//1 в функцию printList 2м параметром - если печатаем в верхнем регистре,
	//2 - если печатаем в нижнем регистре
	if (n==1) {printList(p, 1); return 0;}
	else if (n==2) {printList(p, 2); return 0;}
	//выходим в главное меню если ввод не равен 1 или 2	
	else return 0;
}

//функция печати оценок студентов
//параметр указатель на структуру типа Student
int printMarks(Student *p)//#КР2
{
	Student *s;
	int      i, k, n;
	//объявляем массив указателей на строки
	//инициализируем его названиями месяцев
	char *monthsArr[12]={"January","February","March","April","May","June",\
		"July","August","September","October","November","December"};
	//печатаем список студентов
	printList (p,0);
	//спрашиваем по какому студенту распечатать оценки
	printf("Input number of student: ");
	scanf("%d", &n);
	//находим структуру номер в списке кот. равен выбранному
	while(p!=NULL) {
	if (p->studNmb==n){	s=p; break;}	
	p=p->pnext;}
	
	//выводим шапку таблицы
	printf("\nMarks of a student: #%-d, name:%-s, floor:%-d, room:%-d \n", 
		s->studNmb, s->fname, s->floor, s->roomNmb);
	printf("%s \n","-------------------");
	printf("%s \n","   Months Year     ");
	printf("%s \n","          1 2 3 4 5");
	printf("%s \n","-------------------");
	//с помощью двух циклов выводим элементы многомерного массива
	//т.е. печатаем оценки студента 
	for(k=0;k<12;k++)
	{
		printf("%9s", monthsArr[k]);
		for(i=0;i<5;i++) printf(" %d",s->marks[i][k]);
		printf("\n");
	}
	return 0;//выходим без кода об ошибке
}

//функция добавления оценок студентам
//параметр указатель на структуру типа Student
int addMarks(Student *p)//#КР2
{
	int y,m,r,k;
	//запрашиваем год,месяц за который необходмо добавить оценку
	//и саму оценку
L:	printf("\nInput Year (1-5):");
	scanf("%d", &y);
	printf("\nInput Month (1-12):");
	scanf("%d", &m);
	printf("\nInput Mark (1-5):");
	scanf("%d", &r);
	//поправка на то что в массиве индексы начинаются с нуля
	--y;
	--m;
	//вводим оценку
	p->marks[y][m]=r;
	//предоставляем возможность продолжить вводить оценки
	printf("\nMark entered. \n1.add another \n2.exit to the main menu");
	printf("\nInput the command number :");
	scanf("%d", &k);
	//выходим либо продолжаем вводить оценки
	switch(k)
	{
	case 1: goto L; 
	case 2: goto M;
	}  
M:	return 0;//выходим без кода об ошибке
}